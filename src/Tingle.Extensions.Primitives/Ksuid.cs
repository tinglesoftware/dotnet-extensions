using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Security.Cryptography;
using System.Text.Json.Serialization;
using Tingle.Extensions.Primitives.Converters;

namespace Tingle.Extensions.Primitives;

/// <summary>
/// A K-Sortable Globally Unique IDentifier, based on the reference implementation from
/// <see href="https://github.com/segmentio/ksuid">Segment</see>.
/// It's a way to generate globally unique IDs similar to RFC 4122 UUIDs, but contain a time
/// component so they can be "roughly" sorted by time of creation.
/// The remainder of the KSUID is randomly generated bytes.
/// </summary>
/// <remarks>
/// This struct implementation is backed by a <see cref="uint"/> and 16 random <see cref="byte"/>s.
/// For database storage, it is recommended to use the <see cref="string"/> representation.
/// <br/>
/// The string value will always be a fixed length depending on what string format you use.
/// It contains two segments. The left part contains the timestamp to ensure time-based sorting
/// </remarks>
[JsonConverter(typeof(KsuidJsonConverter))]
[TypeConverter(typeof(KsuidTypeConverter))]
public readonly partial struct Ksuid : IEquatable<Ksuid>, IConvertible, IFormattable
{
    /// <summary>Gets an instance of <see cref="Ksuid"/> where the value is empty.</summary>
    public static readonly Ksuid Empty = default;

    internal const string Base62Format = "B";
    internal const string HexFormat = "H";

    private static readonly DateTimeOffset origin = DateTimeOffset.FromUnixTimeSeconds(0x53724E00);
    private const int TimestampLengthInBytes = 4;
    private const int PayloadLengthInBytes = 16;
    private const int TotalBytesLength = TimestampLengthInBytes + PayloadLengthInBytes;
    private static readonly int Base62EncodedLength = 27;
    private static readonly int HexEncodedLength = 40;

    private readonly byte[] payload;
    private readonly uint timestamp;

    /// <summary>Creates a <see cref="Ksuid"/> from a 20-element byte array.</summary>
    public Ksuid(byte[] bytes)
    {
        ArgumentNullException.ThrowIfNull(bytes);
        if (bytes.Length != TotalBytesLength)
        {
            throw new ArgumentOutOfRangeException(nameof(bytes), $"Only 20 {TotalBytesLength} bytes are allowed.");
        }

        var timestampBytes = new byte[TimestampLengthInBytes];
        Array.Copy(bytes, 0, timestampBytes, 0, TimestampLengthInBytes);
        if (BitConverter.IsLittleEndian) Array.Reverse(timestampBytes);
        timestamp = BitConverter.ToUInt32(timestampBytes, 0);

        payload = new byte[PayloadLengthInBytes];
        Array.Copy(bytes, TimestampLengthInBytes, payload, 0, PayloadLengthInBytes);
    }

    /// <summary>Creates a <see cref="Ksuid"/> from parts.</summary>
    internal Ksuid(DateTimeOffset timestamp, byte[] payload)
        : this(GetTimestampFromDateTime(timestamp), payload) { }

    /// <summary>Creates a <see cref="Ksuid"/> from parts.</summary>
    internal Ksuid(uint timestamp, byte[] payload)
    {
        this.timestamp = timestamp;
        this.payload = payload ?? throw new ArgumentNullException(nameof(payload));
        if (payload.Length != PayloadLengthInBytes)
        {
            throw new ArgumentOutOfRangeException(nameof(payload), $"The payload must have {PayloadLengthInBytes} bytes");
        }
    }

    /// <summary>Gets the timestamp represented in the instance.</summary>
    public long Timestamp => timestamp;

    /// <summary>Gets the timestamp represented in the instance.</summary>
    public DateTimeOffset Created => origin.AddSeconds(timestamp);

    /// <summary>Converts a <see cref="string"/> into a <see cref="Ksuid"/>.</summary>
    /// <param name="s">A string containing the value to convert.</param>
    /// <returns>A <see cref="Ksuid"/> equivalent to the value specified in <paramref name="s"/>.</returns>
    /// <exception cref="ArgumentNullException"><paramref name="s"/> is null.</exception>
    /// <exception cref="FormatException"><paramref name="s"/> is not in a correct format.</exception>
    public static Ksuid Parse(string s)
    {
        ArgumentNullException.ThrowIfNull(s);

        if (TryParse(s, out var result)) return result;
        throw new FormatException($"'{s}' is not a valid KSUID.");
    }

    /// <summary>Converts a <see cref="string"/> into a <see cref="Ksuid"/>.</summary>
    /// <param name="s">A string containing the value to convert.</param>
    /// <param name="value">
    /// When this method returns, contains the value associated parsed,
    /// if successful; otherwise, <see langword="null"/> is returned.
    /// This parameter is passed uninitialized.
    /// </param>
    /// <returns>
    /// <see langword="true"/> if <paramref name="s"/> could be parsed; otherwise, false.
    /// </returns>
    public static bool TryParse(string s, [NotNullWhen(true)] out Ksuid value)
    {
        value = default;
        if (string.IsNullOrWhiteSpace(s))
        {
            return false;
        }

        if (s.Length == Base62EncodedLength)
        {
            value = new(KsuidBase62.FromBase62(s));
            return true;
        }
        else if (s.Length == HexEncodedLength)
        {
            value = new Ksuid(Convert.FromHexString(s));
            return true;
        }

        return false;
    }

    /// <summary>Returns a 20-element byte array that contains the value of this instance.</summary>
    /// <returns>A 20-element byte array.</returns>
    public byte[] ToByteArray()
    {
        var timestampBytes = BitConverter.GetBytes(timestamp);
        if (BitConverter.IsLittleEndian) Array.Reverse(timestampBytes);

        var buffer = new byte[TotalBytesLength];
        Array.Copy(timestampBytes, 0, buffer, 0, timestampBytes.Length);
        if (payload is not null)
        {
            Array.Copy(payload, 0, buffer, timestampBytes.Length, payload.Length);
        }

        return buffer;
    }

    /// <inheritdoc/>
    public override string ToString() => ToString(Base62Format);

    /// <summary>Returns the string representation of the <see cref="Ksuid"/>.</summary>
    /// <param name="format">A format string. Valid values are "B" for base32 format (27 char) and "H" for standard hex format (40 char).</param>
    /// <returns>The formatted string representation of this <see cref="Ksuid"/>.</returns>
    public string ToString(string? format) => ToString(format, CultureInfo.CurrentCulture);

    /// <inheritdoc/>
    public string ToString(string? format, IFormatProvider? formatProvider)
    {
        format ??= Base62Format;

        return format.ToUpperInvariant() switch
        {
            Base62Format => KsuidBase62.ToBase62(ToByteArray()).PadLeft(Base62EncodedLength, '0'),
            HexFormat => Convert.ToHexString(ToByteArray()),
            _ => throw new FormatException($"The {format} format string is not supported."),
        };
    }

    /// <summary>Generates a new <see cref="Ksuid"/> with a unique value.</summary>
    public static Ksuid Generate() => Generate(DateTimeOffset.UtcNow);

    /// <summary>
    /// Generates a new <see cref="Ksuid"/> with a unique value and the timestamp component based on a given <see cref="DateTimeOffset"/>.
    /// </summary>
    /// <param name="timestamp">The timestamp component.</param>
    public static Ksuid Generate(DateTimeOffset timestamp) => Generate(GetTimestampFromDateTime(timestamp));

    /// <summary>
    /// Generates a new <see cref="Ksuid"/> with a unique value and the timestamp component based on a given <see cref="uint"/>.
    /// </summary>
    /// <param name="timestamp">The timestamp component.</param>
    internal static Ksuid Generate(uint timestamp)
    {
        var payload = new byte[PayloadLengthInBytes];
        using var random = RandomNumberGenerator.Create();
        random.GetBytes(payload);

        return new Ksuid(timestamp, payload);
    }

    private static uint GetTimestampFromDateTime(DateTimeOffset timestamp)
    {
        return timestamp < origin
            ? throw new ArgumentOutOfRangeException(nameof(timestamp), $"The timestamp must be after ${origin:O}")
            : Convert.ToUInt32((timestamp - origin).TotalSeconds);
    }

    /// <inheritdoc/>
    public override bool Equals(object? obj) => obj is Ksuid ksuid && Equals(ksuid);

    /// <inheritdoc/>
    public bool Equals(Ksuid other)
    {
        return Enumerable.SequenceEqual(payload ?? [], other.payload ?? [])
               && timestamp == other.timestamp;
    }

    /// <inheritdoc/>
    public override int GetHashCode() => HashCode.Combine(payload, timestamp);

    /// <inheritdoc/>
    public static bool operator ==(Ksuid left, Ksuid right) => left.Equals(right);

    /// <inheritdoc/>
    public static bool operator !=(Ksuid left, Ksuid right) => !(left == right);

    /// <summary>Converts a <see cref="string"/> to a <see cref="Ksuid"/>.</summary>
    /// <param name="s"></param>
    public static implicit operator Ksuid(string s) => Parse(s: s);

    /// <summary>Converts a <see cref="T:byte[]"/> to a <see cref="Ksuid"/>.</summary>
    /// <param name="bytes"></param>
    public static implicit operator Ksuid(byte[] bytes) => new(bytes: bytes);

    /// <summary>Converts a <see cref="Ksuid"/> to a string.</summary>
    /// <param name="id"></param>
    public static implicit operator string(Ksuid id) => id.ToString();

    /// <summary>Converts a <see cref="Ksuid"/> to a <see cref="T:byte[]"/>.</summary>
    /// <param name="id"></param>
    public static implicit operator byte[](Ksuid id) => id.ToByteArray();

    #region IConvertible

    TypeCode IConvertible.GetTypeCode() => TypeCode.Object;
    bool IConvertible.ToBoolean(IFormatProvider? provider) => throw new InvalidCastException();
    byte IConvertible.ToByte(IFormatProvider? provider) => throw new InvalidCastException();
    char IConvertible.ToChar(IFormatProvider? provider) => throw new InvalidCastException();
    DateTime IConvertible.ToDateTime(IFormatProvider? provider) => throw new InvalidCastException();
    decimal IConvertible.ToDecimal(IFormatProvider? provider) => throw new InvalidCastException();
    double IConvertible.ToDouble(IFormatProvider? provider) => throw new InvalidCastException();
    short IConvertible.ToInt16(IFormatProvider? provider) => throw new InvalidCastException();
    int IConvertible.ToInt32(IFormatProvider? provider) => throw new InvalidCastException();
    long IConvertible.ToInt64(IFormatProvider? provider) => throw new InvalidCastException();
    sbyte IConvertible.ToSByte(IFormatProvider? provider) => throw new InvalidCastException();
    float IConvertible.ToSingle(IFormatProvider? provider) => throw new InvalidCastException();
    string IConvertible.ToString(IFormatProvider? provider) => ToString();

    object IConvertible.ToType(Type conversionType, IFormatProvider? provider)
    {
        return Type.GetTypeCode(conversionType) switch
        {
            TypeCode.Decimal => ((IConvertible)this).ToDecimal(provider),
            TypeCode.Double => ((IConvertible)this).ToDouble(provider),
            TypeCode.Int64 => ((IConvertible)this).ToInt64(provider),
            TypeCode.Object when conversionType == typeof(object) => this,
            TypeCode.Object when conversionType == typeof(Ksuid) => this,
            TypeCode.String => ((IConvertible)this).ToString(provider),
            TypeCode.UInt64 => ((IConvertible)this).ToUInt64(provider),
            _ => throw new InvalidCastException(),
        };
    }

    ushort IConvertible.ToUInt16(IFormatProvider? provider) => throw new InvalidCastException();
    uint IConvertible.ToUInt32(IFormatProvider? provider) => throw new InvalidCastException();
    ulong IConvertible.ToUInt64(IFormatProvider? provider) => throw new InvalidCastException();

    #endregion

    internal class KsuidTypeConverter : TypeConverter
    {
        /// <inheritdoc/>
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) => sourceType == typeof(string);

        /// <inheritdoc/>
        public override bool CanConvertTo(ITypeDescriptorContext? context, Type? destinationType) => destinationType == typeof(string);

        /// <inheritdoc/>
        public override object? ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object value)
        {
            return value is string s ? Parse(s) : base.ConvertFrom(context, culture, value);
        }

        /// <inheritdoc/>
        public override object? ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value, Type destinationType)
        {
            return destinationType == typeof(string) && value is Ksuid id
                ? id.ToString()
                : base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
